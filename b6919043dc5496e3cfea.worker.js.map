{"version":3,"sources":["webpack:///b6919043dc5496e3cfea.worker.js","webpack:///webpack/bootstrap b6919043dc5496e3cfea","webpack:///./routes/viewer/lib/uncompress.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","TY4L","importScripts","self","loadArchiveFormats","console","info","regexImage","RegExp","isValidImageType","test","getFileMimeType","mime","exec","handleEntry","entry","index","totalEntries","readData","data","error","postMessage","action","is_file","size","byteLength","blob","Blob","type","url","URL","createObjectURL","message","archive","file","handleUncompress","entries","filter","count","length","tasks","uncompress:start","file_name","password","array_buffer","log","archiveOpenArrayBuffer","e","handleTask","event","addEventListener"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,EAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,EAAAQ,IACAG,OAAAC,eAAAZ,EAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,KAGAzB,IAAA0B,EAAA,UDMMC,KACA,WAEN,YEjEAC,eAAc,iCAGdC,KAAKC,oBAAoB,MAAO,MAAO,OAAQ,iBAC7CC,SAAQC,KAAK,2BAIf,IAAMC,GAAa,GAAIC,QAAO,oCACxBC,EAAmB,SAAAxB,GAAA,MAAQsB,GAAWG,KAAKzB,IAG3C0B,EAAkB,SAAA1B,GACtB,GAAM2B,GAAOL,EAAWM,KAAK5B,EAC7B,iBAAgB2B,EAAOA,EAAK,GAAK,SAG7BE,EAAc,SAACC,EAAOC,EAAOC,GACjCF,EAAMG,SAAS,SAACC,EAAMC,GAQpB,GANIA,GAEFjB,KAAKkB,aAAcC,OAAQ,aAAcF,UAIvCL,EAAMQ,SAAWJ,EAAM,CACzB,GAAIK,GAAOL,EAAKM,WACZxC,EAAO8B,EAAM9B,KACbyC,EAAO,GAAIC,OAAMR,IAASS,KAAMjB,EAAgBI,EAAM9B,QACtD4C,EAAMC,IAAIC,gBAAgBL,GAG1BM,GACFV,OAAQ,kBACRW,SAAWhB,gBACXiB,MAAQL,MAAK5C,OAAMuC,OAAMR,SAI3Bb,MAAKkB,YAAYW,OAKjBG,EAAmB,SAAAF,GAEvB5B,QAAQC,KAAK,iBAAkB2B,EAI/B,KAAK,GAFDG,GAAUH,EAAQG,QAAQC,OAAO,SAAAtB,GAAA,MAASN,GAAiBM,EAAM9B,QAE5D+B,EAAQ,EAAGsB,EAAQF,EAAQG,OAAQvB,EAAQsB,EAAOtB,IACzDF,EAAYsB,EAAQpB,GAAQA,EAAOsB,IAIjCE,GACJC,mBAAoB,SAAAtB,GAAQ,GACpBuB,GAAsCvB,EAAtCuB,UAAWC,EAA2BxB,EAA3BwB,SAAUC,EAAiBzB,EAAjByB,YAC3BvC,SAAQwC,IAAI1B,EACZ,KAEE,GAAIc,GAAU9B,KAAK2C,uBACjBJ,EACAC,EACAC,EAEFX,IAAWE,EAAiBF,GAC5B,MAAOc,GAEP,GAAIf,IAAYV,OAAQ,QAASF,MAAO2B,EAAEf,QAC1C7B,MAAKkB,YAAYW,MAKjBgB,EAAa,SAAAC,GAAS,GAClB3B,GAAW2B,EAAM9B,KAAjBG,MAERkB,GAAMlB,IAAWkB,EAAMlB,GAAQ2B,EAAM9B,MAGvChB,MAAK+C,iBAAiB,UAAWF,GAAY","file":"b6919043dc5496e3cfea.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"TY4L\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"TY4L\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright (c) 2017 Matthew Brennan Jones <matthew.brennan.jones@gmail.com>\n// This software is licensed under a MIT License\n// https://github.com/workhorsy/uncompress.js\n\n\nimportScripts('./assets/lib/js/uncompress.js');\n\n// Load all the archive formats\nself.loadArchiveFormats(['rar', 'zip', 'tar'], function (e) {\n  return console.info('Archive formats loaded');\n});\n\n// Regex to detect image type\nvar regexImage = new RegExp('^.+.(jpeg|jpg|png|bpm|webp|gif)$');\nvar isValidImageType = function isValidImageType(name) {\n  return regexImage.test(name);\n};\n\n// Extract file MIME Type\nvar getFileMimeType = function getFileMimeType(name) {\n  var mime = regexImage.exec(name);\n  return 'image/' + (mime ? mime[1] : 'jpeg');\n};\n\nvar handleEntry = function handleEntry(entry, index, totalEntries) {\n  entry.readData(function (data, error) {\n    // Hanlde error\n    if (error) {\n      // Sen error to main thead\n      self.postMessage({ action: 'error-data', error: error });\n    }\n\n    // Ignore folders\n    if (entry.is_file && data) {\n      var size = data.byteLength;\n      var name = entry.name;\n      var blob = new Blob([data], { type: getFileMimeType(entry.name) });\n      var url = URL.createObjectURL(blob);\n\n      // Create message\n      var message = {\n        action: 'uncompress:each',\n        archive: { totalEntries: totalEntries },\n        file: { url: url, name: name, size: size, index: index }\n\n        // Send entry to main thread\n      };self.postMessage(message);\n    }\n  });\n};\n\nvar handleUncompress = function handleUncompress(archive) {\n  // Debug archive\n  console.info('Uncompressing:', archive);\n  // Get only the entries that are images\n  var entries = archive.entries.filter(function (entry) {\n    return isValidImageType(entry.name);\n  });\n  // Uncompress each entry and send it to the client\n  for (var index = 0, count = entries.length; index < count; index++) {\n    handleEntry(entries[index], index, count);\n  }\n};\n\nvar tasks = {\n  'uncompress:start': function uncompressStart(data) {\n    var file_name = data.file_name,\n        password = data.password,\n        array_buffer = data.array_buffer;\n\n    console.log(data);\n    try {\n      // Open the array buffer as an archive\n      var archive = self.archiveOpenArrayBuffer(file_name, password, array_buffer);\n      archive && handleUncompress(archive);\n    } catch (e) {\n      // Handle error\n      var message = { action: 'error', error: e.message };\n      self.postMessage(message);\n    }\n  }\n};\n\nvar handleTask = function handleTask(event) {\n  var action = event.data.action;\n\n\n  tasks[action] && tasks[action](event.data);\n};\n\nself.addEventListener('message', handleTask, false);\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// b6919043dc5496e3cfea.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"TY4L\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b6919043dc5496e3cfea","// Copyright (c) 2017 Matthew Brennan Jones <matthew.brennan.jones@gmail.com>\n// This software is licensed under a MIT License\n// https://github.com/workhorsy/uncompress.js\n'use strict'\n\nimportScripts('./assets/lib/js/uncompress.js')\n\n// Load all the archive formats\nself.loadArchiveFormats(['rar', 'zip', 'tar'], e =>\n  console.info('Archive formats loaded')\n)\n\n// Regex to detect image type\nconst regexImage = new RegExp('^.+.(jpeg|jpg|png|bpm|webp|gif)$')\nconst isValidImageType = name => regexImage.test(name)\n\n// Extract file MIME Type\nconst getFileMimeType = name => {\n  const mime = regexImage.exec(name)\n  return `image/${mime ? mime[1] : 'jpeg'}`\n}\n\nconst handleEntry = (entry, index, totalEntries) => {\n  entry.readData((data, error) => {\n    // Hanlde error\n    if (error) {\n      // Sen error to main thead\n      self.postMessage({ action: 'error-data', error })\n    }\n\n    // Ignore folders\n    if (entry.is_file && data) {\n      let size = data.byteLength\n      let name = entry.name\n      let blob = new Blob([data], { type: getFileMimeType(entry.name) })\n      let url = URL.createObjectURL(blob)\n\n      // Create message\n      let message = {\n        action: 'uncompress:each',\n        archive: { totalEntries },\n        file: { url, name, size, index },\n      }\n\n      // Send entry to main thread\n      self.postMessage(message)\n    }\n  })\n}\n\nconst handleUncompress = archive => {\n  // Debug archive\n  console.info('Uncompressing:', archive)\n  // Get only the entries that are images\n  let entries = archive.entries.filter(entry => isValidImageType(entry.name))\n  // Uncompress each entry and send it to the client\n  for (let index = 0, count = entries.length; index < count; index++) {\n    handleEntry(entries[index], index, count)\n  }\n}\n\nconst tasks = {\n  'uncompress:start': data => {\n    let { file_name, password, array_buffer } = data\n    console.log(data)\n    try {\n      // Open the array buffer as an archive\n      let archive = self.archiveOpenArrayBuffer(\n        file_name,\n        password,\n        array_buffer\n      )\n      archive && handleUncompress(archive)\n    } catch (e) {\n      // Handle error\n      let message = { action: 'error', error: e.message }\n      self.postMessage(message)\n    }\n  },\n}\n\nconst handleTask = event => {\n  const { action } = event.data\n\n  tasks[action] && tasks[action](event.data)\n}\n\nself.addEventListener('message', handleTask, false)\n\n\n\n// WEBPACK FOOTER //\n// ./routes/viewer/lib/uncompress.worker.js"],"sourceRoot":""}