{"version":3,"sources":["webpack:///272dc6de8063b6489b1d.worker.js","webpack:///webpack/bootstrap 272dc6de8063b6489b1d","webpack:///./routes/viewer/lib/uncompress.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","TY4L","importScripts","regexImage","RegExp","isValidImageType","test","getFileMimeType","mime","exec","handleEntry","index","entry","archive","readData","data","error","self","postMessage","action","payload","is_file","size","byteLength","blob","Blob","type","url","URL","createObjectURL","message","file","handleUncompress","file_name","entries","pages","filter","totalPages","length","tasks","uncompress_start","password","array_buffer","archiveOpenArrayBuffer","handleTask","event","_event$data","loadArchiveFormats","addEventListener","console","info"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4BAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,EAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,EAAAQ,IACAG,OAAAC,eAAAZ,EAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,KAGAzB,IAAA0B,EAAA,UDMMC,KACA,WAEN,YEjEAC,eAAc,4BAGd,IAAMC,GAAa,GAAIC,QAAO,oCAGxBC,EAAmB,SAAApB,GAAA,MAAQkB,GAAWG,KAAKrB,IAG3CsB,EAAkB,SAAAtB,GACtB,GAAMuB,GAAOL,EAAWM,KAAKxB,EAC7B,iBAAgBuB,EAAOA,EAAK,GAAK,SAG7BE,EAAc,SAACC,EAAOC,EAAOC,GACjCD,EAAME,SAAS,SAACC,EAAMC,GAEpB,GAAIA,EAGF,MADAC,MAAKC,aAAcC,OAAQ,QAASC,SAAWJ,YACxC,CAGT,IAAIJ,EAAMS,SAAWN,EAAM,CACzB,GAAMO,GAAOP,EAAKQ,WACZtC,EAAO2B,EAAM3B,KACbuC,EAAO,GAAIC,OAAMV,IAASW,KAAMnB,EAAgBK,EAAM3B,QACtD0C,EAAMC,IAAIC,gBAAgBL,GAE1BM,GACJX,OAAQ,kBACRC,SACEW,MAAQpB,QAAOgB,MAAK1C,OAAMqC,SAIhB,KAAVX,IACFmB,EAAQX,OAAS,mBACjBW,EAAQV,QAAQP,QAAUA,GAG5BI,KAAKC,YAAYY,OAKjBE,EAAmB,SAAAnB,GAKvB,IAAK,GAHc5B,GAAkB4B,EAA7BoB,UAAiBC,EAAYrB,EAAZqB,QACnBC,EAAQD,EAAQE,OAAO,SAAAxB,GAAA,MAASP,GAAiBO,EAAM3B,QAEpD0B,EAAQ,EAAG0B,EAAaF,EAAMG,OAAQ3B,EAAQ0B,EAAY1B,IACjED,EAAYC,EAAOwB,EAAMxB,IAAU1B,OAAMoD,gBAIvCE,GACJC,iBAAkB,SAAAzB,GAChB,IAAI,GAEMkB,GAAsClB,EAAtCkB,UAAWQ,EAA2B1B,EAA3B0B,SAAUC,EAAiB3B,EAAjB2B,aACvB7B,EAAUI,KAAK0B,uBACnBV,EACAQ,EACAC,EAEF7B,IAAWmB,EAAiBnB,GAC5B,MAAOG,GAEP,GAAIc,IACFX,OAAQ,QACRC,SAAWJ,MAAOA,EAAMc,SAE1Bb,MAAKC,YAAYY,MAKjBc,EAAa,SAAAC,GAAS,GAAAC,GACED,EAAM9B,KAA1BI,EADkB2B,EAClB3B,OAAQC,EADU0B,EACV1B,OAChBmB,GAAMpB,IAAWoB,EAAMpB,GAAQC,GAIjCH,MAAK8B,oBAAoB,MAAO,MAAO,OAAQ,WAC7C9B,KAAK+B,iBAAiB,UAAWJ,GAAY,GAC7C3B,KAAKC,aAAcC,OAAQ,UAC3B8B,QAAQC,KAAK","file":"272dc6de8063b6489b1d.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"TY4L\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"TY4L\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright (c) 2017 Matthew Brennan Jones <matthew.brennan.jones@gmail.com>\n// This software is licensed under a MIT License\n// https://github.com/workhorsy/uncompress.js\n\n\nimportScripts('./assets/js/uncompress.js');\n\n// Regex to detect image type\nvar regexImage = new RegExp('^.+.(jpeg|jpg|png|bpm|webp|gif)$');\n\n// Check if file is a valid image-type\nvar isValidImageType = function isValidImageType(name) {\n  return regexImage.test(name);\n};\n\n// Extract file MIME Type\nvar getFileMimeType = function getFileMimeType(name) {\n  var mime = regexImage.exec(name);\n  return 'image/' + (mime ? mime[1] : 'jpeg');\n};\n\nvar handleEntry = function handleEntry(index, entry, archive) {\n  entry.readData(function (data, error) {\n    // Hanlde error\n    if (error) {\n      // Sen error to main thead\n      self.postMessage({ action: 'error', payload: { error: error } });\n      return false;\n    }\n    // Ignore folders\n    if (entry.is_file && data) {\n      var size = data.byteLength;\n      var name = entry.name;\n      var blob = new Blob([data], { type: getFileMimeType(entry.name) });\n      var url = URL.createObjectURL(blob);\n      // Create message\n      var message = {\n        action: 'uncompress_each',\n        payload: {\n          file: { index: index, url: url, name: name, size: size }\n        }\n        // Uncompress cover\n      };if (index === 0) {\n        message.action = 'uncompress_cover';\n        message.payload.archive = archive;\n      }\n      // Send entry to main thread\n      self.postMessage(message);\n    }\n  });\n};\n\nvar handleUncompress = function handleUncompress(archive) {\n  // Get only the entries that are images\n  var name = archive.file_name,\n      entries = archive.entries;\n\n  var pages = entries.filter(function (entry) {\n    return isValidImageType(entry.name);\n  });\n  // Uncompress each entry and send it to the client\n  for (var index = 0, totalPages = pages.length; index < totalPages; index++) {\n    handleEntry(index, pages[index], { name: name, totalPages: totalPages });\n  }\n};\n\nvar tasks = {\n  uncompress_start: function uncompress_start(data) {\n    try {\n      // Open the array buffer as an archive\n      var file_name = data.file_name,\n          password = data.password,\n          array_buffer = data.array_buffer;\n\n      var archive = self.archiveOpenArrayBuffer(file_name, password, array_buffer);\n      archive && handleUncompress(archive);\n    } catch (error) {\n      // Handle error\n      var message = {\n        action: 'error',\n        payload: { error: error.message }\n      };\n      self.postMessage(message);\n    }\n  }\n};\n\nvar handleTask = function handleTask(event) {\n  var _event$data = event.data,\n      action = _event$data.action,\n      payload = _event$data.payload;\n\n  tasks[action] && tasks[action](payload);\n};\n\n// Load all the archive formats\nself.loadArchiveFormats(['rar', 'zip', 'tar'], function () {\n  self.addEventListener('message', handleTask, false);\n  self.postMessage({ action: 'ready' });\n  console.info('Worker ready ...');\n});\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// 272dc6de8063b6489b1d.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"TY4L\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 272dc6de8063b6489b1d","// Copyright (c) 2017 Matthew Brennan Jones <matthew.brennan.jones@gmail.com>\n// This software is licensed under a MIT License\n// https://github.com/workhorsy/uncompress.js\n'use strict'\n\nimportScripts('./assets/js/uncompress.js')\n\n// Regex to detect image type\nconst regexImage = new RegExp('^.+.(jpeg|jpg|png|bpm|webp|gif)$')\n\n// Check if file is a valid image-type\nconst isValidImageType = name => regexImage.test(name)\n\n// Extract file MIME Type\nconst getFileMimeType = name => {\n  const mime = regexImage.exec(name)\n  return `image/${mime ? mime[1] : 'jpeg'}`\n}\n\nconst handleEntry = (index, entry, archive) => {\n  entry.readData((data, error) => {\n    // Hanlde error\n    if (error) {\n      // Sen error to main thead\n      self.postMessage({ action: 'error', payload: { error } })\n      return false\n    }\n    // Ignore folders\n    if (entry.is_file && data) {\n      const size = data.byteLength\n      const name = entry.name\n      const blob = new Blob([data], { type: getFileMimeType(entry.name) })\n      const url = URL.createObjectURL(blob)\n      // Create message\n      const message = {\n        action: 'uncompress_each',\n        payload: {\n          file: { index, url, name, size },\n        },\n      }\n      // Uncompress cover\n      if (index === 0) {\n        message.action = 'uncompress_cover'\n        message.payload.archive = archive\n      }\n      // Send entry to main thread\n      self.postMessage(message)\n    }\n  })\n}\n\nconst handleUncompress = archive => {\n  // Get only the entries that are images\n  const { file_name: name, entries } = archive\n  const pages = entries.filter(entry => isValidImageType(entry.name))\n  // Uncompress each entry and send it to the client\n  for (let index = 0, totalPages = pages.length; index < totalPages; index++) {\n    handleEntry(index, pages[index], { name, totalPages })\n  }\n}\n\nconst tasks = {\n  uncompress_start: data => {\n    try {\n      // Open the array buffer as an archive\n      const { file_name, password, array_buffer } = data\n      const archive = self.archiveOpenArrayBuffer(\n        file_name,\n        password,\n        array_buffer\n      )\n      archive && handleUncompress(archive)\n    } catch (error) {\n      // Handle error\n      let message = {\n        action: 'error',\n        payload: { error: error.message },\n      }\n      self.postMessage(message)\n    }\n  },\n}\n\nconst handleTask = event => {\n  const { action, payload } = event.data\n  tasks[action] && tasks[action](payload)\n}\n\n// Load all the archive formats\nself.loadArchiveFormats(['rar', 'zip', 'tar'], function() {\n  self.addEventListener('message', handleTask, false)\n  self.postMessage({ action: 'ready' })\n  console.info('Worker ready ...')\n})\n\n\n\n// WEBPACK FOOTER //\n// ./routes/viewer/lib/uncompress.worker.js"],"sourceRoot":""}